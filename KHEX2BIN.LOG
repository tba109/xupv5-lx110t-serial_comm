KCPSM3 Assembler log file for program 'khex2bin.psm'.
Generated by KCPSM3 version 1.31
Ken Chapman (Xilinx Ltd) 2005.
10Apr2015-08:41:18

 Addr Code

 000                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 000                         ;;
 000                         ;; Tyler Anderson Tue, Apr 07, 2015 10:07:50 AM
 000                         ;;
 000                         ;; Convert incoming ascii hex character commands to 32-bit
 000                         ;; binary commands. For receiving, u 'x' as start character.
 000                         ;; For transmitting, use 'q' as the start character. Use
 000                         ;; linefeed or space as sentinel for stop.
 000                         ;;
 000                         ;; Used a few ideas from
 000                         ;; http://www.ivysim.com/picoblaze/dec2bin/
 000                         ;;
 000                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 000                         ;; The ASCII characters we are looking for
 000                         ;; http://www.asciitable.com/
 000                         ;;
 000                         CONSTANT ASCII_x, 78
 000                         CONSTANT ASCII_q, 71
 000                         CONSTANT ASCII_lf, 0A
 000                         CONSTANT ASCII_space, 20
 000                         CONSTANT ASCII_0, 30
 000                         CONSTANT ASCII_1, 31
 000                         CONSTANT ASCII_2, 32
 000                         CONSTANT ASCII_3, 33
 000                         CONSTANT ASCII_4, 34
 000                         CONSTANT ASCII_5, 35
 000                         CONSTANT ASCII_6, 36
 000                         CONSTANT ASCII_7, 37
 000                         CONSTANT ASCII_8, 38
 000                         CONSTANT ASCII_9, 39
 000                         CONSTANT ASCII_A, 41
 000                         CONSTANT ASCII_B, 42
 000                         CONSTANT ASCII_C, 43
 000                         CONSTANT ASCII_D, 44
 000                         CONSTANT ASCII_E, 45
 000                         CONSTANT ASCII_F, 46
 000                         ;; Some port id addresses
 000                         ;;
 000                         CONSTANT RX_FIFO_EMPTY, 00
 000                         CONSTANT RX_FIFO_READ, 01
 000                         CONSTANT TX_FIFO_FULL, 10
 000                         CONSTANT TX_FIFO_WRITE, 11
 000                         CONSTANT CMD_FIFO_DATA0, 20
 000                         CONSTANT CMD_FIFO_DATA1, 21
 000                         CONSTANT CMD_FIFO_DATA2, 22
 000                         CONSTANT CMD_FIFO_DATA3, 23
 000                         CONSTANT CMD_FIFO_DATA4, 24
 000                         CONSTANT CMD_FIFO_DATA5, 25
 000                         CONSTANT CMD_FIFO_DATA6, 26
 000                         CONSTANT CMD_FIFO_DATA7, 27
 000                         CONSTANT CMD_FIFO_FULL, 28
 000                         CONSTANT CMD_FIFO_WRITE, 29
 000                         CONSTANT RSP_FIFO_DATA0, 40
 000                         CONSTANT RSP_FIFO_DATA1, 41
 000                         CONSTANT RSP_FIFO_DATA2, 42
 000                         CONSTANT RSP_FIFO_DATA3, 43
 000                         CONSTANT RSP_FIFO_DATA4, 44
 000                         CONSTANT RSP_FIFO_DATA5, 45
 000                         CONSTANT RSP_FIFO_DATA6, 46
 000                         CONSTANT RSP_FIFO_DATA7, 47
 000                         CONSTANT RSP_FIFO_EMPTY, 48
 000                         CONSTANT RSP_FIFO_READ, 49
 000                         ;; Some useful scratch pad memory addresses
 000                         ;;
 000                         CONSTANT ASCII_ADR_LO, 00
 000                         CONSTANT ASCII_ADR_HI, 07
 000                         CONSTANT BIN_ADR_LO, 08
 000                         CONSTANT BIN_ADR_HI, 0F
 000                         CONSTANT MATCH_ADR_LO, 10
 000                         CONSTANT MATCH_ADR_HI, 1F
 000                         ;; Some useful "Out of Range High" (ORH)
 000                         ;; and "Out of Range Low" (ORL) addresses
 000                         ;; for checking loop conditions
 000                         CONSTANT ASCII_ADR_ORL, FF
 000                         CONSTANT ASCII_ADR_ORH, 08
 000                         CONSTANT BIN_ADR_ORL, 07
 000                         CONSTANT BIN_ADR_ORH, 10
 000                         CONSTANT MATCH_ADR_ORL, 0F
 000                         CONSTANT MATCH_ADR_ORH, 20
 000                         ;; Some useful register definitions
 000                         ;;
 000                         NAMEREG s0, xreg                         ;; general purpose variable
 000                         NAMEREG s1, yreg                         ;; general purpose variable
 000                         NAMEREG s2, ascii_ptr                    ;; pointer to ascii rx or rsp hex chars in scratch pad memory
 000                         NAMEREG s3, bin_eqv                      ;; tracks ascii pointer to find binary equivalent of hex char
 000                         NAMEREG s4, bin_ptr                      ;; pointer to binary rx or rsp nybble in scratch pad memory
 000                         NAMEREG s5, match_ptr                    ;; pointer to constant array of hex chars to match to rx or rsp
 000                         NAMEREG s6, cmd_pid                      ;; Port id variable for command writing
 000                         NAMEREG s7, rsp_pid                      ;; Port id variable for response reading
 000                         NAMEREG sD, cnt0                         ;; generic counter variable
 000                         NAMEREG sE, cnt1                         ;; generic counter variable
 000                         NAMEREG sF, retval                       ;; return value for subroutines
 000                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 000                         ;; No interrupt, and initialize the scratch pad with hexchar array to be
 000                         ;; matched
 000                         ;;
 000  3C000            init: DISABLE INTERRUPT
 001  00510                  LOAD match_ptr[s5], MATCH_ADR_LO[10]
 002  00030                  LOAD xreg[s0], ASCII_0[30]
 003  2F050                  STORE xreg[s0], (match_ptr)[(s5)]
 004  18501                  ADD match_ptr[s5], 01
 005  00031                  LOAD xreg[s0], ASCII_1[31]
 006  2F050                  STORE xreg[s0], (match_ptr)[(s5)]
 007  18501                  ADD match_ptr[s5], 01
 008  00032                  LOAD xreg[s0], ASCII_2[32]
 009  2F050                  STORE xreg[s0], (match_ptr)[(s5)]
 00A  18501                  ADD match_ptr[s5], 01
 00B  00033                  LOAD xreg[s0], ASCII_3[33]
 00C  2F050                  STORE xreg[s0], (match_ptr)[(s5)]
 00D  18501                  ADD match_ptr[s5], 01
 00E  00034                  LOAD xreg[s0], ASCII_4[34]
 00F  2F050                  STORE xreg[s0], (match_ptr)[(s5)]
 010  18501                  ADD match_ptr[s5], 01
 011  00035                  LOAD xreg[s0], ASCII_5[35]
 012  2F050                  STORE xreg[s0], (match_ptr)[(s5)]
 013  18501                  ADD match_ptr[s5], 01
 014  00036                  LOAD xreg[s0], ASCII_6[36]
 015  2F050                  STORE xreg[s0], (match_ptr)[(s5)]
 016  18501                  ADD match_ptr[s5], 01
 017  00037                  LOAD xreg[s0], ASCII_7[37]
 018  2F050                  STORE xreg[s0], (match_ptr)[(s5)]
 019  18501                  ADD match_ptr[s5], 01
 01A  00038                  LOAD xreg[s0], ASCII_8[38]
 01B  2F050                  STORE xreg[s0], (match_ptr)[(s5)]
 01C  18501                  ADD match_ptr[s5], 01
 01D  00039                  LOAD xreg[s0], ASCII_9[39]
 01E  2F050                  STORE xreg[s0], (match_ptr)[(s5)]
 01F  18501                  ADD match_ptr[s5], 01
 020  00041                  LOAD xreg[s0], ASCII_A[41]
 021  2F050                  STORE xreg[s0], (match_ptr)[(s5)]
 022  18501                  ADD match_ptr[s5], 01
 023  00042                  LOAD xreg[s0], ASCII_B[42]
 024  2F050                  STORE xreg[s0], (match_ptr)[(s5)]
 025  18501                  ADD match_ptr[s5], 01
 026  00043                  LOAD xreg[s0], ASCII_C[43]
 027  2F050                  STORE xreg[s0], (match_ptr)[(s5)]
 028  18501                  ADD match_ptr[s5], 01
 029  00044                  LOAD xreg[s0], ASCII_D[44]
 02A  2F050                  STORE xreg[s0], (match_ptr)[(s5)]
 02B  18501                  ADD match_ptr[s5], 01
 02C  00045                  LOAD xreg[s0], ASCII_E[45]
 02D  2F050                  STORE xreg[s0], (match_ptr)[(s5)]
 02E  18501                  ADD match_ptr[s5], 01
 02F  00046                  LOAD xreg[s0], ASCII_F[46]
 030  2F050                  STORE xreg[s0], (match_ptr)[(s5)]
 031  18501                  ADD match_ptr[s5], 01
 032                         ;;
 032                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 032                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 032                         ;; This is the main loop
 032                         ;;
 032                         ;; Look for new data from receiver FIFO
 032                         ;;
 032  04000    poll_rx_fifo: INPUT xreg[s0], RX_FIFO_EMPTY[00]        ;; Poll rx fifo empty.
 033  14000                  COMPARE xreg[s0], 00                     ;; Does rx fifo have something?
 034  3543C                  JUMP NZ, poll_rsp_fifo[03C]              ;; If no, go poll rsp fifo
 035  30045                  CALL read_rx[045]                        ;; Read rx and store in memory
 036  14F00                  COMPARE retval[sF], 00                   ;; Was read successful?
 037  3543C                  JUMP NZ, poll_rsp_fifo[03C]              ;; If no, skip to polling rsp fifo
 038  30066                  CALL rx_parse[066]                       ;; Convert rx ascii to binary
 039  14F00                  COMPARE retval[sF], 00                   ;; Was parsing successful?
 03A  3543C                  JUMP NZ, poll_rsp_fifo[03C]              ;; If no, skip to polling rsp fifo
 03B  30079                  CALL write_cmd[079]                      ;; Write binary to cmd fifo
 03C                         ;; Look for new data from the response FIFO
 03C                         ;;
 03C  04048   poll_rsp_fifo: INPUT xreg[s0], RSP_FIFO_EMPTY[48]       ;; Poll rsp fifo empty.
 03D  14000                  COMPARE xreg[s0], 00                     ;; Does rsp fifo have something?
 03E  35432                  JUMP NZ, poll_rx_fifo[032]               ;; In no, go poll rx fifo
 03F  3008C                  CALL read_rsp[08C]                       ;; Read rsp and store in memory
 040  14F00                  COMPARE retval[sF], 00                   ;; Was read successful?
 041  35432                  JUMP NZ, poll_rx_fifo[032]               ;; If no, skip to polling rx fifo
 042  30099                  CALL rsp_parse[099]                      ;; Convert rsp binary to ascii
 043  300AA                  CALL write_tx[0AA]                       ;; Write ascii to tx fifo
 044  34032                  JUMP poll_rx_fifo[032]                   ;; Spin forever
 045                         ;;
 045                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 045                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 045                         ;; Wait for rx fifo to have 'x', which is the start char. Then read it in
 045                         ;; and store all hexchars of command. (Note: these are parsed later.)
 045                         ;; Finally, read in one more char and return an error if it's not the
 045                         ;; sentinel. If, at any point, you timeout while waiting for the rx fifo,
 045                         ;; abort and return 1.
 045                         ;;
 045                         ;; Returns: 0, command successfully read from rx fifo
 045                         ;;          1, command not successfully read from rx fifo
 045                         ;;
 045  3005A         read_rx: CALL get_rx_char[05A]                    ;; Get a char from the rx fifo
 046  14F01                  COMPARE retval[sF], 01                   ;; Did we timeout?
 047  350BC                  JUMP Z, return1[0BC]                     ;; If yes, return with an error
 048  14078                  COMPARE xreg[s0], ASCII_x[78]            ;; Is it the start character?
 049  35445                  JUMP NZ, read_rx[045]                    ;; If no, loop read_rx
 04A  00207                  LOAD ascii_ptr[s2], ASCII_ADR_HI[07]     ;; Init ascii pointer
 04B  3005A      read_rx_l1: CALL get_rx_char[05A]                    ;; Go get the char, store in xreg
 04C  14F01                  COMPARE retval[sF], 01                   ;; Did we successfully read a char?
 04D  350BC                  JUMP Z, return1[0BC]                     ;; If no, return 1
 04E  2F020                  STORE xreg[s0], (ascii_ptr)[(s2)]        ;; Store new char
 04F  1C201                  SUB ascii_ptr[s2], 01                    ;; Calc new char's mem loc
 050  142FF                  COMPARE ascii_ptr[s2], ASCII_ADR_ORL[FF] ;; Are we done reading chars?
 051  3544B                  JUMP NZ, read_rx_l1[04B]                 ;; If no, loop l1
 052  3005A                  CALL get_rx_char[05A]                    ;; Get the last character
 053  14F01                  COMPARE retval[sF], 01                   ;; Did we timeout?
 054  350BC                  JUMP Z, return1[0BC]                     ;; If yes, return with error
 055  1400A                  COMPARE xreg[s0], ASCII_lf[0A]           ;; Is it linefeed?
 056  350BA                  JUMP Z, return0[0BA]                     ;; If yes, SUCCESS! Return 0!
 057  14020                  COMPARE xreg[s0], ASCII_space[20]        ;; Is it space?
 058  350BA                  JUMP Z, return0[0BA]                     ;; If yes, SUCCESS! Return 0!
 059  340BC                  JUMP return1[0BC]                        ;; FAIL! No sentinel! Return 1!
 05A  00DFF     get_rx_char: LOAD cnt0[sD], FF                        ;; Init outer counter
 05B  00EFF  get_rx_char_l1: LOAD cnt1[sE], FF                        ;; Init inner counter
 05C  04000  get_rx_char_l2: INPUT xreg[s0], RX_FIFO_EMPTY[00]        ;; read the rx fifo empty signal
 05D  14000                  COMPARE xreg[s0], 00                     ;; Does rx fifo have something?
 05E  35064                  JUMP Z, get_rx_char_rd[064]              ;; If yes, go read it in
 05F  1CE01                  SUB cnt1[sE], 01                         ;; Decrement inner counter
 060  3545C                  JUMP NZ, get_rx_char_l2[05C]             ;; Loop inner if not expired
 061  1CD01                  SUB cnt0[sD], 01                         ;; Decrement outer counter
 062  3545B                  JUMP NZ, get_rx_char_l1[05B]             ;; Loop outer if not expired
 063  340BC                  JUMP return1[0BC]                        ;; FAIL! Return 1!
 064  04001  get_rx_char_rd: INPUT xreg[s0], RX_FIFO_READ[01]         ;; Read in RX FIFO
 065  340BA                  JUMP return0[0BA]                        ;; SUCCESS! Return 0!
 066                         ;;
 066                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 066                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 066                         ;; Parse through the ascii rx packet, testing the current character
 066                         ;; against our constant array of matching characters. Store the binary
 066                         ;; equivalent result in scratch pad memory.
 066                         ;;
 066                         ;; We require 8 hexchars ('0' thru '9' or 'A' thru 'F'). If anything is
 066                         ;; amiss, abort.
 066                         ;;
 066                         ;; Returns: 0, parse sucessful
 066                         ;;          1, parse aborted
 066                         ;;
 066  00200        rx_parse: LOAD ascii_ptr[s2], ASCII_ADR_LO[00]     ;; Init the ascii pointer
 067  00408                  LOAD bin_ptr[s4], BIN_ADR_LO[08]         ;; Init the binary pointer
 068  00510     rx_parse_l2: LOAD match_ptr[s5], MATCH_ADR_LO[10]     ;; Init match pointer
 069  00300                  LOAD bin_eqv[s3], 00                     ;; Init binary equivalent value
 06A  07020     rx_parse_l1: FETCH xreg[s0], (ascii_ptr)[(s2)]        ;; Get the first hexchar
 06B  07150                  FETCH yreg[s1], (match_ptr)[(s5)]        ;; Get the first match for test
 06C  15010                  COMPARE xreg[s0], yreg[s1]               ;; Does hexchar match?
 06D  35073                  JUMP Z, rx_parse_sbe[073]                ;; If yes, store binary equiv
 06E  1451F                  COMPARE match_ptr[s5], MATCH_ADR_HI[1F]  ;; Have we tested all match?
 06F  350BC                  JUMP Z, return1[0BC]                     ;; If yes, match failed! Abort!
 070  18501                  ADD match_ptr[s5], 01                    ;; If no, increment match address
 071  18301                  ADD bin_eqv[s3], 01                      ;; If no, increment binary equiv
 072  3406A                  JUMP rx_parse_l1[06A]                    ;; Loop
 073  2F340    rx_parse_sbe: STORE bin_eqv[s3], (bin_ptr)[(s4)]       ;; Store bin equiv at bin pointer
 074  18401                  ADD bin_ptr[s4], 01                      ;; Increment bin pointer
 075  18201                  ADD ascii_ptr[s2], 01                    ;; Increment ascii pointer
 076  14208                  COMPARE ascii_ptr[s2], ASCII_ADR_ORH[08] ;; Parsed all 8 characters?
 077  35468                  JUMP NZ, rx_parse_l2[068]                ;; If no, loop l2
 078  340BA                  JUMP return0[0BA]                        ;; Success! Return 0!
 079                         ;;
 079                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 079                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 079                         ;; Write all nybbles of the command word. Wait for CMD FIFO not full.
 079                         ;; If timeout, abort and return 1.
 079                         ;;
 079                         ;; Returns: 0, CMD word successfully written to CMD FIFO
 079                         ;;          1, CMD word not successfully written to CMD FIFO
 079                         ;;
 079  00DFF       write_cmd: LOAD cnt0[sD], FF                        ;; Init outer counter
 07A  00EFF    write_cmd_l1: LOAD cnt1[sE], FF                        ;; Init inner counter
 07B  04028    write_cmd_l2: INPUT xreg[s0], CMD_FIFO_FULL[28]        ;; Read the CMD FIFO full signal
 07C  14000                  COMPARE xreg[s0], 00                     ;; Is CMD_FIFO full?
 07D  35083                  JUMP Z, cmd_wr[083]                      ;; If no, set command nybbles and write
 07E  1CE01                  SUB cnt1[sE], 01                         ;; Decrement inner couter
 07F  3547B                  JUMP NZ, write_cmd_l2[07B]               ;; Loop inner if not expired
 080  1CD01                  SUB cnt0[sD], 01                         ;; Decrement outer counter
 081  3547A                  JUMP NZ, write_cmd_l1[07A]               ;; Loop outer if not expired
 082  340BC                  JUMP return1[0BC]                        ;; FAIL! Return 1!
 083  00408          cmd_wr: LOAD bin_ptr[s4], BIN_ADR_LO[08]         ;; Init binary pointer
 084  00620                  LOAD cmd_pid[s6], CMD_FIFO_DATA0[20]     ;; Init command port id pointer
 085  07340       cmd_wr_l1: FETCH bin_eqv[s3], (bin_ptr)[(s4)]       ;; Get the bin eqv from memory
 086  2D360                  OUTPUT bin_eqv[s3], (cmd_pid)[(s6)]      ;; Set the output nybble
 087  18401                  ADD bin_ptr[s4], 01                      ;; Incrememt bin_ptr
 088  18601                  ADD cmd_pid[s6], 01                      ;; Increment cmd_pid
 089  14410                  COMPARE bin_ptr[s4], BIN_ADR_ORH[10]     ;; Are we done writing?
 08A  35485                  JUMP NZ, cmd_wr_l1[085]                  ;; If no, loop.
 08B  340BA                  JUMP return0[0BA]                        ;; Done
 08C                         ;;
 08C                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 08C                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 08C                         ;; Poll for RSP FIFO not empty and read all nybbles of response word,
 08C                         ;; storing them in memory.
 08C                         ;;
 08C                         ;; Returns: 0, RSP word successfully read from RSP FIFO and stored
 08C                         ;;          1, RSP word not successful read from RSP FIFO and stored
 08C                         ;;
 08C  04048        read_rsp: INPUT xreg[s0], RSP_FIFO_EMPTY[48]       ;; Poll rsp fifo empty
 08D  14000                  COMPARE xreg[s0], 00                     ;; Does rsp fifo have something?
 08E  354BC                  JUMP NZ, return1[0BC]                    ;; If no, return 1
 08F  2C049                  OUTPUT xreg[s0], RSP_FIFO_READ[49]       ;; Read rsp fifo
 090  00408                  LOAD bin_ptr[s4], BIN_ADR_LO[08]         ;; Init binary pointer
 091  00740                  LOAD rsp_pid[s7], RSP_FIFO_DATA0[40]     ;; Init response port id
 092  05370     read_rsp_l1: INPUT bin_eqv[s3], (rsp_pid)[(s7)]       ;; Read rsp nybble
 093  2F340                  STORE bin_eqv[s3], (bin_ptr)[(s4)]       ;; Store rsp nybble
 094  18701                  ADD rsp_pid[s7], 01                      ;; Increment rsp port id
 095  18401                  ADD bin_ptr[s4], 01                      ;; Increment binary pointer
 096  14410                  COMPARE bin_ptr[s4], BIN_ADR_ORH[10]     ;; Are we done reading response?
 097  35492                  JUMP NZ, read_rsp_l1[092]                ;; If no, loop l1
 098  340BA                  JUMP return0[0BA]                        ;; If yes, return 0
 099                         ;;
 099                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 099                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 099                         ;; Parse through the binary rsp packet, converting binary nybbles to
 099                         ;; hexchar equivalents. Store the result in scratch pad memory.
 099                         ;;
 099                         ;; Returns: 0, success (should always find match)
 099                         ;;
 099  00408       rsp_parse: LOAD bin_ptr[s4], BIN_ADR_LO[08]         ;; Init the binary pointer
 09A  00200                  LOAD ascii_ptr[s2], ASCII_ADR_LO[00]     ;; Init the ascii pointer
 09B  00510    rsp_parse_l2: LOAD match_ptr[s5], MATCH_ADR_LO[10]     ;; Init the match pointer
 09C  00300                  LOAD bin_eqv[s3], 00                     ;; Init the binary equivalent
 09D  07040                  FETCH xreg[s0], (bin_ptr)[(s4)]          ;; Get the nybble
 09E  15030    rsp_parse_l1: COMPARE xreg[s0], bin_eqv[s3]            ;; Did we find a match?
 09F  350A5                  JUMP Z, rsp_parse_sam[0A5]               ;; If yes, store ascii match
 0A0  14410                  COMPARE bin_ptr[s4], BIN_ADR_ORH[10]     ;; Are we done parsing response?
 0A1  350BA                  JUMP Z, return0[0BA]                     ;; If yes, succecss! Return 0!
 0A2  18501                  ADD match_ptr[s5], 01                    ;; Increment match pointer
 0A3  18301                  ADD bin_eqv[s3], 01                      ;; Increment binary equivalent
 0A4  3409E                  JUMP rsp_parse_l1[09E]                   ;; Loop l1
 0A5  07050   rsp_parse_sam: FETCH xreg[s0], (match_ptr)[(s5)]        ;; Get the hexchar
 0A6  2F020                  STORE xreg[s0], (ascii_ptr)[(s2)]        ;; Store it in scratch pad memory
 0A7  18401                  ADD bin_ptr[s4], 01                      ;; Increment the binary pointer
 0A8  18201                  ADD ascii_ptr[s2], 01                    ;; Increment the ascii pointer
 0A9  3409B                  JUMP rsp_parse_l2[09B]                   ;; Go process the next character
 0AA                         ;;
 0AA                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 0AA                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 0AA                         ;; Write a start character. Then write all hexchars to the tx fifo.
 0AA                         ;; Finally, write a sentinel linefeed. Block at tx fifo full. Note that
 0AA                         ;; as long as the transmitter is draining the tx fifo at some point,
 0AA                         ;; hangups won't happen here.
 0AA                         ;;
 0AA                         ;; Returns: 0, success (should always be able to write, eventually...)
 0AA                         ;;
 0AA  00071        write_tx: LOAD xreg[s0], ASCII_q[71]               ;; Init xreg with the starting char
 0AB  300B5                  CALL wr_tx_l1[0B5]                       ;; Write the start character
 0AC  00200                  LOAD ascii_ptr[s2], ASCII_ADR_LO[00]     ;; Init the ascii pointer
 0AD  07020     write_tx_l1: FETCH xreg[s0], (ascii_ptr)[(s2)]        ;; Get the hexchar from memory
 0AE  300B5                  CALL wr_tx_l1[0B5]                       ;; Write the hexchar to tx fifo
 0AF  18201                  ADD ascii_ptr[s2], 01                    ;; Increment ascii pointer
 0B0  14208                  COMPARE ascii_ptr[s2], ASCII_ADR_ORH[08] ;; Are we done?
 0B1  354AD                  JUMP NZ, write_tx_l1[0AD]                ;; If no, loop l1
 0B2  0000A                  LOAD xreg[s0], ASCII_lf[0A]              ;; Init xreg with the sentinel
 0B3  300B5                  CALL wr_tx_l1[0B5]                       ;; Write the sentinel
 0B4  340BA                  JUMP return0[0BA]                        ;; Success! Return 0!
 0B5  04110        wr_tx_l1: INPUT yreg[s1], TX_FIFO_FULL[10]         ;; Get tx fifo full flag
 0B6  14101                  COMPARE yreg[s1], 01                     ;; Is the tx fifo full?
 0B7  350B5                  JUMP Z, wr_tx_l1[0B5]                    ;; If yes, loop l1
 0B8  2C011                  OUTPUT xreg[s0], TX_FIFO_WRITE[11]       ;; Write hexchar to the tx fifo
 0B9  2A000                  RETURN                                   ;; Done writing, return
 0BA                         ;;
 0BA                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 0BA                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 0BA                         ;; These guys save a line of code on return. (They make the code
 0BA                         ;; shorter, too.)
 0BA                         ;;
 0BA  00F00         return0: LOAD retval[sF], 00                      ;; generic return 0
 0BB  2A000                  RETURN
 0BC  00F01         return1: LOAD retval[sF], 01                      ;; generic return 1
 0BD  2A000                  RETURN
 0BE                         ;;
 0BE                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
