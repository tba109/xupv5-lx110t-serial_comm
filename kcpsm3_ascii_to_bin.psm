;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Tyler Anderson Tue, Apr 07, 2015 10:07:50 AM
;;
;; Convert 8-character hex commands to 32-bit commands.
;; Use linefeed or space as sentinel for end of command. 
;;
;; Borrowed a few ideas from
;; http://www.ivysim.com/picoblaze/dec2bin/
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; The ASCII characters we are looking for
;; http://www.asciitable.com/
;;
CONSTANT ASCII_lf,    0a
CONSTANT ASCII_space, 20
CONSTANT ASCII_0,     30
CONSTANT ASCII_1,     31
CONSTANT ASCII_2,     32
CONSTANT ASCII_3,     33
CONSTANT ASCII_4,     34
CONSTANT ASCII_5,     35
CONSTANT ASCII_6,     36
CONSTANT ASCII_7,     37
CONSTANT ASCII_8,     38
CONSTANT ASCII_9,     39
CONSTANT ASCII_A,     41
CONSTANT ASCII_B,     42
CONSTANT ASCII_C,     43
CONSTANT ASCII_D,     44
CONSTANT ASCII_E,     45
CONSTANT ASCII_F,     46
CONSTANT ASCII_a,     61
CONSTANT ASCII_b,     62
CONSTANT ASCII_c,     63
CONSTANT ASCII_d,     64
CONSTANT ASCII_e,     65
CONSTANT ASCII_f,     66

;; Some port id addresses
;;
CONSTANT RX_FIFO_EMPTY , 01
CONSTANT RX_FIFO_READ  , 02
CONSTANT CMD_FIFO_FULL , 03
CONSTANT CMD_FIFO_DATA0, 04
CONSTANT CMD_FIFO_DATA1, 05
CONSTANT CMD_FIFO_DATA2, 06
CONSTANT CMD_FIFO_DATA3, 07
CONSTANT CMD_FIFO_DATA4, 08
CONSTANT CMD_FIFO_DATA5, 09
CONSTANT CMD_FIFO_DATA6, 0a
CONSTANT CMD_FIFO_DATA07 0b
CONSTANT CMD_FIFO_WRITE, 0c
CONSTANT TX_FIFO_FULL  , 0d
CONSTANT TX_FIFO_WRITE , 0e
CONSTANT RSP_FIFO_EMPTY, 0f
CONSTANT RSP_FIFO_READ0, 10
CONSTANT RSP_FIFO_READ1, 11
CONSTANT RSP_FIFO_READ2, 12
CONSTANT RSP_FIFO_READ3, 13

;; Some useful scratch pad memory addresses
;;
CONSTANT ASCII_ADR_LO, 00
CONSTANT ASCII_ADR_HI, 08
CONSTANT BIN_ADR_LO  , ASCII_ADR_HI + 1
CONSTANT BIN_ADR_HI  , BIN_ADR_LOW  + 7
CONSTANT MATCH_ADR_LO, BIN_ADR_HI   + 1
CONSTANT MATCH_ADR_HI, BIN_ADR_LOW  + 22

;; Some useful register definitions
;;
NAMEREG xreg       , s0
NAMEREG yreg       , s1
NAMEREG ascii_ptr  , s2
NAMEREG bin_eqv    , s3
NAMEREG bin_ptr    , s4
NAMEREG match_ptr  , s5
NAMEREG cmd_pid    , s6
NAMEREG cnt0       , SD
NAMEREG cnt1       , sE
NAMEREG retval     , sF

                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	        ;; No interrupt, and initialize the scratch pad with hexchar array to be 
                ;; matched
		;;
	  init: DISABLE INTERRUPT                  
	        STORE   ASCII_0    , xreg
		ADD     xreg       , 01
		STORE   ASCII_1    , xreg
		ADD     xreg       , 01
		STORE   ASCII_2    , xreg
		ADD     xreg       , 01
		STORE   ASCII_3    , xreg
		ADD     xreg       , 01
		STORE   ASCII_4    , xreg
		ADD     xreg       , 01
		STORE   ASCII_5    , xreg
		ADD     xreg       , 01
		STORE   ASCII_6    , xreg
		ADD     xreg       , 01
		STORE   ASCII_7    , xreg
		ADD     xreg       , 01
		STORE   ASCII_8    , xreg
		ADD     xreg       , 01
		STORE   ASCII_9    , xreg
		ADD     xreg       , 01
		STORE   ASCII_a    , xreg
		ADD     xreg       , 01
		STORE   ASCII_b    , xreg
		ADD     xreg       , 01
		STORE   ASCII_c    , xreg
		ADD     xreg       , 01
		STORE   ASCII_d    , xreg
		ADD     xreg       , 01
		STORE   ASCII_e    , xreg
		ADD     xreg       , 01
		STORE   ASCII_f    , xreg
		ADD     xreg       , 01
		STORE   ASCII_A    , xreg
		ADD     xreg       , 01
		STORE   ASCII_B    , xreg
		ADD     xreg       , 01
		STORE   ASCII_C    , xreg
		ADD     xreg       , 01
		STORE   ASCII_D    , xreg
		ADD     xreg       , 01
		STORE   ASCII_E    , xreg
		ADD     xreg       , 01
		STORE   ASCII_F    , xreg				
                ;;
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; This is the main loop 
		;;
  
                ;; Look for new data from receiver FIFO
                ;;
  poll_rx_fifo: INPUT   xreg  , RX_FIFO_EMPTY  ;; Poll rx fifo empty.
	        COMPARE xreg  , 0              ;; Does rx fifo have something?
                JUMP    NZ    , poll_rsp_fifo  ;; If no, go poll rsp fifo
                CALL            read_rx        ;; Read rx and store in memory
                COMPARE retval, 0              ;; Was read successful?
                JUMP    NZ    , poll_rsp_fifo  ;; If no, skip to polling rsp fifo
                CALL            rx_parse       ;; Convert rx ascii to binary
		COMPARE retval, 0              ;; Was parsing successful?                
                JUMP    NZ    , poll_rsp_fifo  ;; If no, skip to polling rsp fifo
                CALL            write_cmd      ;; Write binary to cmd fifo
 
 poll_rsp_fifo: INPUT   xreg  , RSP_FIFO_EMPTY ;; Poll rsp fifo empty.
                COMPARE xreg  , 0              ;; Does rsp fifo have something?
                JUMP    NZ    , poll_rx_fifo   ;; In no, go poll rx fifo
                CALL            read_rsp       ;; Read rsp and store in memory
                COMPARE retval, 0              ;; Was read successful?
                JUMP    NZ    , poll_rx_fifo   ;; If no, skip to polling rx fifo  
		CALL            rsp_parse      ;; Convert rsp binary to ascii
                COMPARE retval, 0              ;; Was parsing successful?
                JUMP    NZ    , poll_rx_fifo   ;; If no, skip to polling rx fifo
                CALL            write_tx       ;; Write ascii to tx fifo
                JUMP            poll_rx_fifo   ;; Spin forever
                ;;
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; Poll for response data and, if pending, read it in
		;;
                ;; Returns: 0, command successfully read from rx fifo
                ;;          1, command not successfully read from rx fifo
                ;;
       read_rx: LOAD    ascii_ptr, ASCII_ADR_HI      ;; Init ascii pointer 
    read_rx_l1: CALL               get_rx_char       ;; Go get the char, store in xreg 
		COMPARE retval   , 01                ;; Did we successfully read a char?
		JUMP    Z        , return1           ;; If no, return 1
                STORE   xreg     , (ascii_ptr)       ;; Store new char
                SUB     ascii_ptr, 01                ;; Calc new char's mem loc
                COMPARE ascii_ptr, ASCII_ADR_LOW - 1 ;; Are we done reading chars?
                JUMP    NZ       , read_rx_l1        ;; If no, loop l1
		JUMP               return0           ;; If yes, return 0
		;;
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; Read the RX FIFO and store its contents in xreg
                ;; 
                ;; Returns: 0, character read successfully
                ;;          1, character not read
		;;
   get_rx_char: LOAD    cnt0, ff                    ;; Init outer counter
get_rx_char_l1: LOAD    cnt1, ff                    ;; Init inner counter
get_rx_char_l2: INPUT   xreg, RX_FIFO_EMPTY         ;; read the rx fifo empty signal
                COMPARE xreg, 0                     ;; Does rx fifo have something?
                JUMP    Z   , get_rx_char_rd        ;; If yes, go read it in
		SUB     cnt1, 1                     ;; Decrement inner counter
                JUMP    NZ  , get_rx_char_l2        ;; Loop inner if not expired
                SUB     cnt0, 1                     ;; Decrement outer counter
                JUMP    NZ  , get_rx_char_l1        ;; Loop outer if not expired
                JUMP          return1               ;; FAIL! Return 1!

get_rx_char_rd:	INPUT   xreg, RX_FIFO_READ          ;; Read in RX FIFO
                JUMP          return0               ;; SUCCESS! Return 0!
                ;;
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; Parse through the ascii rx packet, testing the current character
                ;; against our constant array of matching characters. Store the binary
                ;; equivalent result in scratch pad memory.
                ;;
                ;; We expect 8 hexchars ('0' thru '9', 'a' thru 'f', or 'A' thru 'F') 
                ;; followed by a sentinel '\n' or ' '. We require *exactly* this pattern.
                ;; If anything is amiss, abort.
                ;; 
                ;; Returns: 0, parse sucessful
                ;;          1, parse aborted
		;;
      rx_parse: LOAD    ascii_ptr, ASCII_ADR_LO  ;; Init the ascii pointer
                LOAD    bin_ptr  , BIN_ADR_LO    ;; Init the binary pointer
   rx_parse_l2: LOAD    match_ptr, MATCH_ADR_LO  ;; Init match adr
  		LOAD    bin_eqv  , 0             ;; Init binary equivalent value
   rx_parse_l1:	FETCH   xreg     , (ascii_ptr)   ;; Get the first hexchar
		FETCH   yreg     , (match_ptr)   ;; Get the first match for test
                COMPARE xreg     , yreg          ;; Does hexchar match?  
		JUMP    Z        , rx_parse_sbe  ;; If yes, store binary equiv
                COMPARE match_ptr, MATCH_ADR_HI  ;; Have we tested all match?
                JUMP    Z        , return1       ;; If yes, match failed! Abort!
                ADD     match_ptr, 1             ;; If no, increment match address
                ADD     bin_eqv  , 1             ;; If no, increment binary equiv
                JUMP               rx_parse_l1   ;; Loop
		
  rx_parse_sbe: STORE   bin_eqv  , (bin_ptr)     ;; Store bin equiv at bin pointer
                ADD     bin_ptr  , 01            ;; Increment bin pointer
                ADD     ascii_ptr, 01            ;; Increment ascii pointer
                COMPARE ascii_ptr, ASCII_ADR_HI  ;; Parsed all 8 characters?
                JUMP    NZ       , rx_parse_l2   ;; If no, loop l2 
                JUMP    Z        , test_sent     ;; If yes, test for sentinel

     test_sent: FETCH   xreg, (ascii_ptr)        ;; Get the sentinel character
                COMPARE xreg, ascii_lf           ;; Is it linefeed?
		JUMP    Z   , return0            ;; If yes, SUCCESS! Return 0!
		COMPARE xreg, ascii_space        ;; Is it space?
		JUMP    Z   , return0            ;; If yes, SUCCESS! Return 0!
		JUMP          return1            ;; FAIL! No sentinel found! Return 1!
                ;;
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	        ;; Write all nybbles of the command word. Wait for CMD FIFO not full
		;; until timeout. If timeout, abort and return 1.
		;;
		;; Returns: 0, CMD word successfully written to CMD FIFO
		;;          1, CMD word not successfully written to CMD FIFO
		;;
     write_cmd: LOAD    cnt0, ff              ;; Init outer counter
  write_cmd_l1: LOAD    cnt1, ff              ;; Init inner counter
  write_cmd_l2: INPUT   xreg, CMD_FIFO_FULL   ;; Read the CMD FIFO full signal
		COMPARE xreg, 0               ;; Is CMD_FIFO full?
		JUMP    Z   , cmd_wr          ;; If no, set command nybbles and write
		SUB     cnt1, 1               ;; Decrement inner couter
		JUMP    NZ  , write_cmd_l2    ;; Loop inner if not expired
                SUB     cnt0, 1               ;; Decrement outer counter
                JUMP    NZ  , write_cmd_l1    ;; Loop outer if not expired
		JUMP          return1         ;; FAIL! Return 1!

        cmd_wr: LOAD    bin_ptr, BIN_ADR_LO     ;; Init binary pointer
                LOAD    cmd_pid, CMD_FIFO_DATA0 ;; Init command port id pointer
     cmd_wr_l1: FETCH   bin_eqv, (bin_ptr)      ;; Get the bin eqv from memory
		OUTPUT  bin_eqv, cmd_pid        ;; Set the output nybble
		ADD     bin_ptr, 01             ;; Incrememt bin_ptr
                ADD     cmd_pid, 01             ;; Increment cmd_pid
		COMPARE bin_ptr, BIN_ADR_HI + 1 ;; Are we done writting?
		JUMP    NZ     , cmd_wr_l1      ;; If no, loop.
		JUMP           , return0        ;; Done 
                ;;
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	        ;; I think these guys should each save a line of code on return
		;; If anything, they make the code read more cleanly
		;;
       return0: LOAD retval, 00 ;; generic return 0
                RETURN
       
       retval1: LOAD retval, 01 ;; generic return 1
                RETURN
                ;;
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
