;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Tyler Anderson Tue, Apr 07, 2015 10:07:50 AM
;;
;; Convert 8-character hex commands to 32-bit commands.
;; Use linefeed or space as sentinel for end of command. 
;;
;; Borrowed a few ideas from
;; http://www.ivysim.com/picoblaze/dec2bin/
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; The ASCII characters we are looking for
;; http://www.asciitable.com/
;;
CONSTANT ASCII_lf,    0a
CONSTANT ASCII_space, 20
CONSTANT ASCII_0,     30
CONSTANT ASCII_1,     31
CONSTANT ASCII_2,     32
CONSTANT ASCII_3,     33
CONSTANT ASCII_4,     34
CONSTANT ASCII_5,     35
CONSTANT ASCII_6,     36
CONSTANT ASCII_7,     37
CONSTANT ASCII_8,     38
CONSTANT ASCII_9,     39
CONSTANT ASCII_A,     41
CONSTANT ASCII_B,     42
CONSTANT ASCII_C,     43
CONSTANT ASCII_D,     44
CONSTANT ASCII_E,     45
CONSTANT ASCII_F,     46
CONSTANT ASCII_a,     61
CONSTANT ASCII_b,     62
CONSTANT ASCII_c,     63
CONSTANT ASCII_d,     64
CONSTANT ASCII_e,     65
CONSTANT ASCII_f,     66

;; Some port id addresses
;;
CONSTANT RX_FIFO_EMPTY , 01
CONSTANT RX_FIFO_READ  , 02
CONSTANT CMD_FIFO_FULL , 03
CONSTANT CMD_FIFO_DATA0, 04
CONSTANT CMD_FIFO_DATA1, 05
CONSTANT CMD_FIFO_DATA2, 06
CONSTANT CMD_FIFO_DATA3, 07
CONSTANT CMD_FIFO_WRITE, 08
CONSTANT TX_FIFO_FULL  , 09
CONSTANT TX_FIFO_WRITE , 0a
CONSTANT RSP_FIFO_EMPTY, 0b
CONSTANT RSP_FIFO_READ0, 0c
CONSTANT RSP_FIFO_READ1, 0d
CONSTANT RSP_FIFO_READ2, 0e
CONSTANT RSP_FIFO_READ3, 0f

;; Some useful scratch pad memory addresses
;;
CONSTANT ASCII_ADR_LO, 00
CONSTANT ASCII_ADR_HI, 08
CONSTANT BIN_ADR_LO  , ASCII_ADR_HI + 1
CONSTANT BIN_ADR_HI  , BIN_ADR_LOW  + 7
CONSTANT MATCH_ADR_LO, BIN_ADR_HI   + 1
CONSTANT MATCH_ADR_HI, BIN_ADR_LOW  + 

;; Some useful register definitions
;;
NAMEREG xreg       , s0
NAMEREG yreg       , s1
NAMEREG ascii_ptr  , s2
NAMEREG bin_eqv    , s3
NAMEREG bin_eqb_ptr, s4
NAMEREG match_ptr  , s5
NAMEREG cnt0       , SD
NAMEREG cnt1       , sE
NAMEREG retval     , sF

                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	        ;; No interrupt, and initialize the scratch pad with characters to be 
                ;; matched
		;;
	  init: DISABLE INTERRUPT                  
	        STORE   ASCII_0    , xreg
		ADD     xreg       , 01
		STORE   ASCII_1    , xreg
		ADD     xreg       , 01
		STORE   ASCII_2    , xreg
		ADD     xreg       , 01
		STORE   ASCII_3    , xreg
		ADD     xreg       , 01
		STORE   ASCII_4    , xreg
		ADD     xreg       , 01
		STORE   ASCII_5    , xreg
		ADD     xreg       , 01
		STORE   ASCII_6    , xreg
		ADD     xreg       , 01
		STORE   ASCII_7    , xreg
		ADD     xreg       , 01
		STORE   ASCII_8    , xreg
		ADD     xreg       , 01
		STORE   ASCII_9    , xreg
		ADD     xreg       , 01
		STORE   ASCII_a    , xreg
		ADD     xreg       , 01
		STORE   ASCII_b    , xreg
		ADD     xreg       , 01
		STORE   ASCII_c    , xreg
		ADD     xreg       , 01
		STORE   ASCII_d    , xreg
		ADD     xreg       , 01
		STORE   ASCII_e    , xreg
		ADD     xreg       , 01
		STORE   ASCII_f    , xreg
		ADD     xreg       , 01
		STORE   ASCII_A    , xreg
		ADD     xreg       , 01
		STORE   ASCII_B    , xreg
		ADD     xreg       , 01
		STORE   ASCII_C    , xreg
		ADD     xreg       , 01
		STORE   ASCII_D    , xreg
		ADD     xreg       , 01
		STORE   ASCII_E    , xreg
		ADD     xreg       , 01
		STORE   ASCII_F    , xreg				
                ;;
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; This is the main loop 
		;;
  
                ;; Look for new data from receiver FIFO
                ;;
  poll_rx_fifo: INPUT   xreg  , RX_FIFO_EMPTY ;; Poll rx fifo empty.
	        COMPARE xreg  , 0             ;; Does rx fifo have something?
		CALL    Z     , read_rx       ;; If yes, read rx and store in memory
                JUMP    NZ    , poll_rsp_fifo ;; If no, skip to polling rsp fifo
                COMPARE retval, 0             ;; Was read successful?
                CALL    Z     , rx_parse      ;; If yes, convert rx ascii to binary
                JUMP    NZ    , poll_rsp_fifo ;; If no, skip to polling rsp fifo
		COMPARE retval, 0             ;; Was parsing successful?                
                CALL    Z     , write_cmd     ;; If yes, write binary to cmd fifo
             ;; JUMP    NZ    , poll_rsp_fifo ;; In no, skip to polling rsp fifo (fallthru)
                
		;; Look for new data from response FIFO
		;;
 poll_rsp_fifo: ;; TBA_NOTE: Write this tomorrow

		JUMP          poll_rx_fifo  ;; Spin here forever
                ;;
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; Poll for response data and, if pending, read it in
		;;
                ;; Returns: 0, command successfully read from rx fifo
                ;;          1, command not successfully read from rx fifo
       read_rx: LOAD    ascii_ptr, ASCII_ADR_HI + 1 ;; setup 
    read_rx_l1: CALL               get_rx_char      ;; Go get the char, store in xreg 
		COMPARE retval   , 01               ;; Did we successfully read a char?
		JUMP    Z        , return1          ;; If no, return 1
                SUB     ascii_ptr, 01               ;; If yes, calc new char's mem loc
		STORE   xreg     , (ascii_ptr)      ;; Store new char
		COMPARE ascii_ptr, ASCII_ADR_LOW    ;; Are we done reading chars?
		JUMP    NZ       , read_rx_l1       ;; If no, loop
		JUMP               return0          ;; If yes, return 0
                ;;
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; Read the RX FIFO and store its contents in xreg. 
                ;; 
                ;; Returns: 0, character read successfully
                ;;          1, character not read
		;;
   get_rx_char: LOAD    cnt0, ff                    ;; Init outer counter
get_rx_char_l1: LOAD    cnt1, ff                    ;; Init inner counter
get_rx_char_l2: INPUT   xreg, RX_FIFO_EMPTY         ;; read the rx fifo empty signal
                COMPARE xreg, 0                     ;; Does rx fifo have something?
                JUMP    Z   , get_rx_char_rd        ;; If yes, go read it in
		SUB     cnt1, 1                     ;; If no, decrement inner counter
                COMPARE cnt1, 0                     ;; Has inner counter expired?
                JUMP    NZ  , get_rx_char_l2        ;; If no, loop inner 
                SUB     cnt0, 1                     ;; In yes, decrement outer counter
                COMPARE cnt0, 0                     ;; Has outer counter expired?
                JUMP    Z   , get_rx_char_l1        ;; If no, loop outer
                JUMP    Z,    return1               ;; If yes, we've failed! Return 1!
get_rx_char_rd:	INPUT   xreg, RX_FIFO_READ          ;; Read in RX FIFO
                JUMP          return0               ;; Success! Return 0!
                ;;
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; Parse through the ascii rx packet, testing the current character
                ;; against our constant array of matching characters. Store the binary
                ;; equivalent result in scratch pad memory.
                ;;
                ;; We expect 8 hexchars ('0' thru '9', 'a' thru 'f', or 'A' thru 'F') 
                ;; followed by a sentinel '\n' or ' '. We require *exactly* this pattern.
                ;; If anything is amiss, abort.
                ;; 
                ;; Returns: 0, parse sucessful
                ;;          1, parse aborted
		;;
      rx_parse: LOAD    ascii_ptr, ASCII_ADR_HI  ;; Init the ascii pointer
   rx_parse_l2: LOAD    match_ptr, MATCH_ADR_LO  ;; Init match adr
  		LOAD    bin_eqv  , 0             ;; Init binary equivalent value
   rx_parse_l1:	FETCH   xreg     , (ascii_ptr)   ;; Get the first hexchar
		FETCH   yreg     , (match_ptr)   ;; Get the first match for test
                COMPARE xreg     , yreg          ;; Does hexchar match?  
		JUMP    Z        , rx_parse_sbe  ;; If yes, store binary equiv
                COMPARE match_ptr, MATCH_ADR_HI  ;; Have we tested all match?
                JUMP    Z        , return1       ;; If yes, match failed! Abort!
                
                ADD     match_ptr, 1             ;; If no, increment match address
                ADD     bin_eqv  , 1             ;; If no, increment binary equiv
                JUMP               rx_parse_l1   ;; Loop

  rx_parse_sbe: ;; Store the binary equivalent at binary equivalent pointer
                ;; Increment binary equivalent pointer
  rx_parse_dap: ;; Increment ascii pointer
                ;; Have we found all 8 characters?
                ;; If yes, get the sentinel
                ;; If no, jump to l2
                
  
                ;;
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
           
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; Read in the RSP FIFO and store its contents in scratch pad memory
		;; Store the result in xreg
		;;
     test_sent: FETCH   xreg, (ascii_ptr)
                COMPARE xreg, ascii_lf
		JUMP    Z   , return0
		COMPARE xreg, ascii_space
		JUMP    Z   , return0
		JUMP          return1
                ;;
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	        ;; I think these guys should each save a line of code on return
		;; If anything, they make the code read more cleanly
		;;
       return0: LOAD retval, 00 ;; generic return 0
                RETURN
       
       retval1: LOAD retval, 01 ;; generic return 1
                RETURN
                ;;
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
